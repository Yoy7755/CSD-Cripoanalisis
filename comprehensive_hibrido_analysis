"""
Comprehensive analysis of hibrido_improved algorithm across all 50 numbers.
Tests each number and provides detailed statistics and summary tables.
"""

import time
from math import gcd
from random import randrange
import csv
from dataclasses import dataclass
from typing import Optional, List
from factorizacion import EllipticCurve, Point

@dataclass
class TestResult:
    """Store results from testing one number"""
    number_index: int
    number: int
    success: bool
    factor_found: Optional[int]
    other_factor: Optional[int]
    total_time: float
    curves_attempted: int
    
    # Time breakdown
    setup_time: float
    multiplication_time: float
    gcd_time: float
    check_time: float
    
    # Operation counts
    scalar_multiplications: int
    gcd_calculations: int
    point_checks: int
    
    # How factor was found
    found_via_zerodiv: bool
    found_via_gcd_x: bool
    found_via_gcd_y: bool
    
    # Factor details
    zerodiv_count: int
    gcd_x_hits: int
    gcd_y_hits: int

def hibrido_improved_tracked(n: int, B: int = 2000, timeout: float = 1800.0) -> TestResult:
    """
    Modified hibrido_improved that tracks detailed statistics
    """
    start_time = time.time()
    
    # Counters and timers
    curve_attempts = 0
    scalar_multiplications = 0
    gcd_calculations = 0
    point_none_checks = 0
    zerodiv_count = 0
    gcd_x_hits = 0
    gcd_y_hits = 0
    
    setup_time = 0
    multiplication_time = 0
    gcd_time = 0
    check_time = 0
    
    # Result tracking
    factor_found = None
    found_via_zerodiv = False
    found_via_gcd_x = False
    found_via_gcd_y = False
    
    while time.time() - start_time < timeout:
        curve_attempts += 1
        
        try:
            # Track setup time
            setup_start = time.time()
            x = randrange(n)
            y = randrange(n)
            a = randrange(n)
            b = (pow(y, 2, n) - pow(x, 3, n) - (a * x) % n) % n
            
            c = EllipticCurve(a, b, n)
            P = Q = Point(c, x, y)
            setup_time += time.time() - setup_start
            
            for i in range(1, B + 1):
                # Track scalar multiplication time
                mult_start = time.time()
                P = P * (2*i)  
                Q = Q * i
                multiplication_time += time.time() - mult_start
                scalar_multiplications += 2
                
                # Track check time
                check_start = time.time()
                if P != None and Q != None:
                    point_none_checks += 1
                    check_time += time.time() - check_start
                    
                    # Track GCD time for y coordinates
                    gcd_start = time.time()
                    factor = gcd((P.y - Q.y) % n, n)
                    gcd_time += time.time() - gcd_start
                    gcd_calculations += 1
                    
                    if 1 < factor < n:
                        factor_found = factor
                        found_via_gcd_y = True
                        gcd_y_hits += 1
                        break
                    
                    # Track GCD time for x coordinates
                    gcd_start = time.time()
                    factor = gcd((P.x - Q.x) % n, n)
                    gcd_time += time.time() - gcd_start
                    gcd_calculations += 1
                    
                    if 1 < factor < n:
                        factor_found = factor
                        found_via_gcd_x = True
                        gcd_x_hits += 1
                        break
                else:
                    check_time += time.time() - check_start
                
                # Break if factor found
                if factor_found:
                    break
            
            # Break if factor found
            if factor_found:
                break
                
        except ZeroDivisionError as e:
            zerodiv_count += 1
            den_str = str(e).split()
            if len(den_str) > 0:
                try:
                    factor = gcd(int(den_str[0]), n)
                    if 1 < factor < n:
                        factor_found = factor
                        found_via_zerodiv = True
                        break
                except ValueError:
                    pass
    
    total_time = time.time() - start_time
    
    # Calculate other factor if found
    other_factor = None
    if factor_found and factor_found > 1:
        other_factor = n // factor_found
    
    return TestResult(
        number_index=-1,  # Will be set by caller
        number=n,
        success=factor_found is not None and 1 < factor_found < n,
        factor_found=factor_found,
        other_factor=other_factor,
        total_time=total_time,
        curves_attempted=curve_attempts,
        setup_time=setup_time,
        multiplication_time=multiplication_time,
        gcd_time=gcd_time,
        check_time=check_time,
        scalar_multiplications=scalar_multiplications,
        gcd_calculations=gcd_calculations,
        point_checks=point_none_checks,
        found_via_zerodiv=found_via_zerodiv,
        found_via_gcd_x=found_via_gcd_x,
        found_via_gcd_y=found_via_gcd_y,
        zerodiv_count=zerodiv_count,
        gcd_x_hits=gcd_x_hits,
        gcd_y_hits=gcd_y_hits
    )

def run_comprehensive_analysis(B: int = 2000, timeout: float = 1800.0):
    """Run analysis on all 50 numbers"""
    
    # All 50 numbers
    test_numbers_80bit = [161281206098678787909586287780757909381,
 280641673723419080757416007628644512347,
 121938978497782286462591920523923276687,
 189608927431220982672256893103370965871,
 288004100803581473102902202440260492383,
 184250220398475730031804374902418439129,
 116820598947084108476997828346823523671,
 186079363747730548580485566452723784317,
 117421042223181682820538963576536232019,
 102791056965963312180585658598458934933,
 181423017460857466111191305556514269607,
 218397797065550082008703033076739935387,
 222963518847316310123352822826442075737,
 201509587681815143232412913218836450617,
 155648308971220577982048681090409183517,
 235478653549152415127668234347857512639,
 212512909285833055275324871072642746731,
 105636413062325425473441727146828750647,
 173056139179303737989122827419797871747,
 131849338043506089578386937730606877937,
 170951122441517746269004526810437490479,
 199784121010439313959858722398924297097,
 117662154795514133607543213327381117781,
 148572928749275049237690796233852818299,
 97897345965490502519435630624750993939,
 149458204578395197417173146353772271257,
 208740108159413564807502863979996006943,
 198506142666657878171529905646026290661,
 233558056160705914450229240081623745851,
 205153389170281190091789683277538829957,
 203483337462287106041894234266962499817,
 119870716473752550690550189680976523723,
 189573311293346969063864574067934530387,
 184688658885202294598128591278936620447,
 121038342701458054159996788376708236691,
 152218516325613279270157501950671687363,
 164750124703777135556697767433585651359,
 140516762290366697616088243595549867141,
 300752349839308647407638236998831905873,
 169352463375638213739348085557475038941,
 187895079269992195713045522044823965261,
    ]
    
    print("COMPREHENSIVE HIBRIDO_IMPROVED ANALYSIS")
    print("=" * 60)
    print(f"Testing all {len(test_numbers_80bit)} numbers")
    print(f"Parameters: B={B}, timeout={timeout}s per number")
    print(f"Estimated total time: {len(test_numbers_80bit) * timeout / 3600:.1f} hours (if all timeout)")
    print("=" * 60)
    
    results: List[TestResult] = []
    
    for i, n in enumerate(test_numbers_80bit):
        print(f"\nTesting number #{i+1}/50: {n}")
        print(f"Bit length: {n.bit_length()}")
        
        start_test = time.time()
        result = hibrido_improved_tracked(n, B=B, timeout=timeout)
        result.number_index = i
        elapsed_test = time.time() - start_test
        
        if result.success:
            print(f"✓ SUCCESS: Found factor {result.factor_found} in {elapsed_test:.1f}s")
            print(f"  Other factor: {result.other_factor}")
            print(f"  Verification: {result.factor_found * result.other_factor == n}")
            
            if result.found_via_zerodiv:
                print(f"  Found via ZeroDivisionError")
            elif result.found_via_gcd_x:
                print(f"  Found via GCD of x-coordinates")
            elif result.found_via_gcd_y:
                print(f"  Found via GCD of y-coordinates")
        else:
            print(f"✗ FAILED: No factor found in {elapsed_test:.1f}s")
        
        print(f"  Curves attempted: {result.curves_attempted}")
        print(f"  Total operations: {result.scalar_multiplications} mults, {result.gcd_calculations} gcds")
        
        results.append(result)
        
        # Save intermediate results
        save_results_to_csv(results, f"hibrido_results_intermediate.csv")
    
    # Final analysis
    print_summary_table(results)
    save_results_to_csv(results, "hibrido_results_final128.csv")
    
    return results

def print_summary_table(results: List[TestResult]):
    """Print comprehensive summary statistics"""
    
    print("\n" + "=" * 80)
    print("FINAL SUMMARY STATISTICS")
    print("=" * 80)
    
    # Basic success statistics
    successful = [r for r in results if r.success]
    failed = [r for r in results if not r.success]
    
    print(f"\nSUCCESS RATE:")
    print(f"Successful factorizations: {len(successful)}/{len(results)} ({len(successful)/len(results)*100:.1f}%)")
    print(f"Failed factorizations: {len(failed)}/{len(results)} ({len(failed)/len(results)*100:.1f}%)")
    
    if len(successful) == 0:
        print("No successful factorizations found.")
        return
    
    # Method of finding factors
    zerodiv_successes = [r for r in successful if r.found_via_zerodiv]
    gcd_x_successes = [r for r in successful if r.found_via_gcd_x]
    gcd_y_successes = [r for r in successful if r.found_via_gcd_y]
    
    print(f"\nFACTOR DISCOVERY METHODS:")
    print(f"Found via ZeroDivisionError: {len(zerodiv_successes)} ({len(zerodiv_successes)/len(successful)*100:.1f}% of successes)")
    print(f"Found via GCD of x-coordinates: {len(gcd_x_successes)} ({len(gcd_x_successes)/len(successful)*100:.1f}% of successes)")
    print(f"Found via GCD of y-coordinates: {len(gcd_y_successes)} ({len(gcd_y_successes)/len(successful)*100:.1f}% of successes)")
    
    # Time statistics (for successful cases)
    avg_total_time = sum(r.total_time for r in successful) / len(successful)
    avg_setup_time = sum(r.setup_time for r in successful) / len(successful)
    avg_mult_time = sum(r.multiplication_time for r in successful) / len(successful)
    avg_gcd_time = sum(r.gcd_time for r in successful) / len(successful)
    avg_check_time = sum(r.check_time for r in successful) / len(successful)
    
    print(f"\nAVERAGE TIMING (Successful cases only):")
    print(f"Total time: {avg_total_time:.2f}s")
    print(f"Setup time: {avg_setup_time:.3f}s ({avg_setup_time/avg_total_time*100:.1f}%)")
    print(f"Multiplication time: {avg_mult_time:.2f}s ({avg_mult_time/avg_total_time*100:.1f}%)")
    print(f"GCD time: {avg_gcd_time:.2f}s ({avg_gcd_time/avg_total_time*100:.1f}%)")
    print(f"Check time: {avg_check_time:.3f}s ({avg_check_time/avg_total_time*100:.1f}%)")
    
    # Operation statistics
    avg_curves = sum(r.curves_attempted for r in successful) / len(successful)
    avg_scalar_mults = sum(r.scalar_multiplications for r in successful) / len(successful)
    avg_gcd_calcs = sum(r.gcd_calculations for r in successful) / len(successful)
    
    print(f"\nAVERAGE OPERATIONS (Successful cases only):")
    print(f"Curves attempted: {avg_curves:.1f}")
    print(f"Scalar multiplications: {avg_scalar_mults:.0f}")
    print(f"GCD calculations: {avg_gcd_calcs:.0f}")
    
    # Performance per operation
    if avg_scalar_mults > 0:
        time_per_mult = avg_mult_time / avg_scalar_mults * 1000
        print(f"Time per scalar multiplication: {time_per_mult:.3f}ms")
    
    if avg_gcd_calcs > 0:
        time_per_gcd = avg_gcd_time / avg_gcd_calcs * 1000
        print(f"Time per GCD calculation: {time_per_gcd:.3f}ms")
    
    # Min/Max statistics
    min_time = min(r.total_time for r in successful)
    max_time = max(r.total_time for r in successful)
    min_curves = min(r.curves_attempted for r in successful)
    max_curves = max(r.curves_attempted for r in successful)
    
    print(f"\nRANGE STATISTICS (Successful cases):")
    print(f"Fastest factorization: {min_time:.2f}s ({min_curves} curves)")
    print(f"Slowest factorization: {max_time:.2f}s ({max_curves} curves)")
    
    # Factor size analysis
    small_factors = [r for r in successful if r.factor_found and r.factor_found < 1000]
    medium_factors = [r for r in successful if r.factor_found and 1000 <= r.factor_found < 10**6]
    large_factors = [r for r in successful if r.factor_found and r.factor_found >= 10**6]
    
    print(f"\nFACTOR SIZE DISTRIBUTION:")
    print(f"Small factors (<1000): {len(small_factors)}")
    print(f"Medium factors (1K-1M): {len(medium_factors)}")
    print(f"Large factors (>1M): {len(large_factors)}")
    
    if small_factors:
        print(f"WARNING: Found {len(small_factors)} small factors - may indicate weak numbers or algorithm issues")

def save_results_to_csv(results: List[TestResult], filename: str):
    """Save detailed results to CSV file"""
    
    with open(filename, 'w', newline='') as csvfile:
        fieldnames = [
            'number_index', 'number', 'success', 'factor_found', 'other_factor',
            'total_time', 'curves_attempted', 'setup_time', 'multiplication_time',
            'gcd_time', 'check_time', 'scalar_multiplications', 'gcd_calculations',
            'point_checks', 'found_via_zerodiv', 'found_via_gcd_x', 'found_via_gcd_y',
            'zerodiv_count', 'gcd_x_hits', 'gcd_y_hits'
        ]
        
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        
        for result in results:
            writer.writerow({
                'number_index': result.number_index,
                'number': result.number,
                'success': result.success,
                'factor_found': result.factor_found,
                'other_factor': result.other_factor,
                'total_time': f"{result.total_time:.3f}",
                'curves_attempted': result.curves_attempted,
                'setup_time': f"{result.setup_time:.6f}",
                'multiplication_time': f"{result.multiplication_time:.3f}",
                'gcd_time': f"{result.gcd_time:.3f}",
                'check_time': f"{result.check_time:.6f}",
                'scalar_multiplications': result.scalar_multiplications,
                'gcd_calculations': result.gcd_calculations,
                'point_checks': result.point_checks,
                'found_via_zerodiv': result.found_via_zerodiv,
                'found_via_gcd_x': result.found_via_gcd_x,
                'found_via_gcd_y': result.found_via_gcd_y,
                'zerodiv_count': result.zerodiv_count,
                'gcd_x_hits': result.gcd_x_hits,
                'gcd_y_hits': result.gcd_y_hits
            })
    
    print(f"\nDetailed results saved to {filename}")

def main():
    import argparse
    parser = argparse.ArgumentParser(description='Comprehensive analysis of hibrido_improved on all 50 numbers')
    parser.add_argument('--B', type=int, default=2000, help='B parameter for iterations')
    parser.add_argument('--timeout', type=float, default=1800.0, help='Timeout per number in seconds')
    parser.add_argument('--quick', action='store_true', help='Quick test with reduced parameters')
    
    args = parser.parse_args()
    
    if args.quick:
        print("Running quick test with reduced parameters...")
        B = 500
        timeout = 300.0  # 5 minutes per number
    else:
        B = args.B
        timeout = args.timeout
    
    print(f"Starting comprehensive analysis...")
    print(f"This will test all 50 numbers with B={B}, timeout={timeout}s each")
    
    estimated_hours = 50 * timeout / 3600
    print(f"Estimated maximum time: {estimated_hours:.1f} hours")
    
    response = input("Continue? (y/n): ")
    if response.lower() != 'y':
        print("Analysis cancelled.")
        return
    
    # Run the analysis
    results = run_comprehensive_analysis(B=B, timeout=timeout)
    
    print(f"\nAnalysis complete! Results saved to CSV files.")

if __name__ == "__main__":
    main()