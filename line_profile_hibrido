"""
Line-by-line profiling for the specific hibrido_improved algorithm

Usage:
1. Install line_profiler: pip install line_profiler
2. Run: python -m kernprof -l line_profile_hibrido_complete.py
3. View results: python -m line_profiler line_profile_hibrido_complete.py.lprof
"""

import time
from math import gcd
from random import randrange

# Import your classes
from factorizacion import EllipticCurve, Point

# The @profile decorator is added by kernprof, but we define it here
# to avoid syntax errors when running the script normally
try:
    profile
except NameError:
    def profile(func):
        return func

@profile
def hibrido_improved(n: int, B: int = 3000, timeout: float = 345600.0):
    start_time = time.time()
    
    while time.time() - start_time < timeout:
        try:
            x = randrange(n)
            y = randrange(n)
            a = randrange(n)
            b = (pow(y, 2, n) - pow(x, 3, n) - (a * x) % n) % n
            
            c = EllipticCurve(a, b, n)
            P = Q = Point(c, x, y)
            
            for i in range(1, B + 1):
                P = P * (2*i)  
                Q = Q * i 
                if P != None and Q != None: 
                    factor = gcd((P.y - Q.y) % n, n)
                    if 1 < factor < n:
                        return factor
                    factor = gcd((P.x - Q.x) % n, n)
                    if 1 < factor < n:
                        return factor
        
        except ZeroDivisionError as e:
            den_str = str(e).split()
            if len(den_str) > 0:
                try:
                    factor = gcd(int(den_str[0]), n)
                    if 1 < factor < n:
                        return factor
                except ValueError:
                    pass
    
    return None

@profile 
def analyze_point_multiplication(n, iterations=20):
    """Profile just the point multiplication operations"""
    x = randrange(n)
    y = randrange(n) 
    a = randrange(n)
    b = (pow(y, 2, n) - pow(x, 3, n) - (a * x) % n) % n
    
    c = EllipticCurve(a, b, n)
    P = Point(c, x, y)
    
    for i in range(1, iterations + 1):
        # These are the expensive operations
        P_new = P * (2*i)
        Q_new = P * i
        
        # Calculate differences
        diff_x = (P_new.x - Q_new.x) % n
        diff_y = (P_new.y - Q_new.y) % n
        
        # GCD operations
        gcd_x = gcd(diff_x, n)
        gcd_y = gcd(diff_y, n)

@profile
def analyze_curve_setup(n, num_curves=10):
    """Profile the curve setup operations"""
    for _ in range(num_curves):
        x = randrange(n)
        y = randrange(n)
        a = randrange(n)
        b = (pow(y, 2, n) - pow(x, 3, n) - (a * x) % n) % n
        
        c = EllipticCurve(a, b, n)
        P = Point(c, x, y)

def main():
    # 80-bit numbers provided by user - first few for line profiling
    test_numbers_80bit = [
        698396313498980295728821,
        557837613227400534046783,
        647645541328318302699191,
        549783678299824126627913,
        591681820821890381318081,
    ]
    
    print("Line-by-line profiling of hibrido_improved")
    print("=" * 50)
    
    # Test with first 80-bit number
    n = test_numbers_80bit[0]
    bits = n.bit_length()
    print(f"Testing {bits}-bit number: {n}")
    
    # Moderate timeout and B for line profiling
    timeout = 300.0  # 5 minutes
    B = 500
    
    print(f"\n1. Full algorithm profiling (B={B}, timeout={timeout}s)")
    result = hibrido_improved(n, B=B, timeout=timeout)
    if result and 1 < result < n:
        other_factor = n // result
        print(f"✓ Found factor: {result}")
        print(f"  Other factor: {other_factor}")
        print(f"  Verification: {result * other_factor == n}")
        
        # Check for trivial factors
        if result < 1000:
            print(f"  WARNING: Found small factor - may not be proper semiprime")
    else:
        print("✗ No factor found within timeout")
    
    print(f"\n2. Point multiplication analysis (10 iterations)")
    analyze_point_multiplication(n, 10)
    
    print(f"\n3. Curve setup analysis (5 curves)")
    analyze_curve_setup(n, 5)
    
    print("\nProfiling complete!")
    print("Run 'python -m line_profiler line_profile_hibrido_complete.py.lprof' to see detailed results")

if __name__ == "__main__":
    main()